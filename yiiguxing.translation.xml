<application>
  <component name="AppStorage">
    <histories>
      <item value="Performs an operation repeatedly until it returns `false`. The operation, [action], may be either synchronous or asynchronous. The operation is called repeatedly as long as it returns either the [bool] value `true` or a `Future&lt;bool&gt;` which completes with the value `true`. If a call to [action] returns `false` or a [Future] that completes to `false`, iteration ends and the future returned by [doWhile] is completed with a `null` value. If a call to [action] throws or a future returned by [action] completes with an error, iteration ends and the future returned by [doWhile] completes with the same error. Calls to [action] may happen at any time, including immediately after calling `doWhile`. The only restriction is a new call to [action] won't happen before the previous call has returned, and if it returned a `Future&lt;bool&gt;`, not until that future has completed." />
      <item value="Waits for multiple futures to complete and collects their results. Returns a future which will complete once all the provided futures have completed, either with their results, or with an error if any of the provided futures fail. The value of the returned future will be a list of all the values that were produced in the order that the futures are provided by iterating [futures]. If any future completes with an error, then the returned future completes with that error. If further futures also complete with errors, those errors are discarded. If `eagerError` is true, the returned future completes with an error immediately on the first error from one of the futures. Otherwise all futures must complete before the returned future is completed (still with the first error; the remaining errors are silently dropped). In the case of an error, [cleanUp] (if provided), is invoked on any non-null result of successful futures. This makes it possible to `cleanUp` resources that would otherwise be lost (since the returned future does not provide access to these values). The [cleanUp] function is unused if there is no error. The call to [cleanUp] should not throw. If it does, the error will be an uncaught asynchronous error." />
      <item value="Returns the result of the first future in [futures] to complete. The returned future is completed with the result of the first future in [futures] to report that it is complete, whether it's with a value or an error. The results of all the other futures are discarded. If [futures] is empty, or if none of its futures complete, the returned future never completes." />
      <item value="Refresh" />
      <item value="Show the refresh indicator and run the refresh callback as if it had been started interactively. If this method is called while the refresh callback is running, it quietly does nothing. Creating the [RefreshIndicator] with a [GlobalKey&lt;RefreshIndicatorState&gt;] makes it possible to refer to the [RefreshIndicatorState]. The future returned from this method completes when the [RefreshIndicator.onRefresh] callback's future completes. If you await the future returned by this function from a [State], you should check that the state is still [mounted] before calling [setState]. When initiated in this manner, the refresh indicator is independent of any actual scroll view. It defaults to showing the indicator at the top. To show it at the bottom, set `atTop` to false." />
      <item value="The domain of where to find the error code. This field is only available on iOS and represents a &quot;domain&quot; from where the [errorCode] is from. This value is taken directly from an `NSError` in Objective-C. See https:developer.apple.comlibraryarchivedocumentationCocoaConceptualErrorHandlingCocoaErrorObjectsDomainsErrorObjectsDomains.html for more information on error handling on iOS." />
      <item value="Description of the error that can be used to communicate the problem to the user." />
      <item value="Gets the URL for which the resource request was made. This value is not provided on iOS. Alternatively, you can keep track of the last values provided to [WebViewPlatformController.loadUrl]." />
      <item value="Invoked when a web resource has failed to load. This can be called for any resource (iframe, image, etc.), not just for the main page." />
      <item value="Invoked when a page has finished loading. This is invoked only for the main frame. When [onPageFinished] is invoked on Android, the page being rendered may not be updated yet. When invoked on iOS or Android, any Javascript code that is embedded directly in the HTML has been loaded and code injected with [WebViewController.evaluateJavascript] can assume this." />
      <item value="Consults the current route's [Route.willPop] method, and acts accordingly, potentially popping the route as a result; returns whether the pop request should be considered handled. {@template flutter.widgets.navigator.maybePop} If [Route.willPop] returns [RoutePopDisposition.pop], then the [pop] method is called, and this method returns true, indicating that it handled the pop request. If [Route.willPop] returns [RoutePopDisposition.doNotPop], then this method returns true, but does not do anything beyond that. If [Route.willPop] returns [RoutePopDisposition.bubble], then this method returns false, and the caller is responsible for sending the request to the containing scope (e.g. by closing the application). This method is typically called for a user-initiated [pop]. For example on Android it's called by the binding for the system's back button. The `T` type argument is the type of the return value of the current route. (Typically this isn't known; consider specifying `dynamic` or `Null`.) {@endtemplate} See also: [Form], which provides an `onWillPop` callback that enables the form to veto a [pop] initiated by the app's back button. [ModalRoute], which provides a `scopedWillPopCallback` that can be used to define the route's `willPop` method." />
      <item value="unrestricted" />
      <item value="is Scroll Controlled" />
      <item value="shrink Wrap" />
      <item value="separated" />
      <item value="Paged" />
      <item value="Fetch" />
      <item value="Always Scrollable Scroll Physics" />
      <item value="Specifies that this view should permit nested scrolling within a compatible ancestor view." />
      <item value="Constant" />
      <item value="Whether the decoration is the same size as the input field." />
      <item value="Whether to show or hide a child. By default, the [visible] property controls whether the [child] is included in the subtree or not; when it is not [visible], the [replacement] child (typically a zero-sized box) is included instead. A variety of flags can be used to tweak exactly how the child is hidden. (Changing the flags dynamically is discouraged, as it can cause the [child] subtree to be rebuilt, with any state in the subtree being discarded. Typically, only the [visible] flag is changed dynamically.) These widgets provide some of the facets of this one: [Opacity], which can stop its child from being painted. [Offstage], which can stop its child from being laid out or painted. [TickerMode], which can stop its child from being animated. [ExcludeSemantics], which can hide the child from accessibility tools. [IgnorePointer], which can disable touch interactions with the child. Using this widget is not necessary to hide children. The simplest way to hide a child is just to not include it, or, if a child _must_ be given (e.g. because the parent is a [StatelessWidget]) then to use [SizedBox.shrink] instead of the child that would otherwise be included. See also: [AnimatedSwitcher], which can fade from one child to the next as the subtree changes. [AnimatedCrossFade], which can fade between two specific children." />
      <item value="Whether to show or hide a child." />
      <item value="guide" />
      <item value="embedding" />
      <item value="INSTALL FAILED SHARED USER INCOMPATIBLE" />
      <item value="normalized Number" />
      <item value="remark" />
      <item value="mark" />
      <item value="BEHAVIOR SET USER VISIBLE HINT" />
      <item value="BEHAVIOR RESUME ONLY CURRENT FRAGMENT" />
      <item value="datum" />
      <item value="税收政策" />
      <item value="tax" />
      <item value="招商引资" />
      <item value="投资动向" />
      <item value="项目" />
      <item value="Conference" />
      <item value="招商会议" />
      <item value="项目投资" />
      <item value="header View" />
      <item value="会员企业" />
      <item value="企业" />
      <item value="推荐" />
      <item value="介绍" />
      <item value="lint Vital移动平板阿里云Release" />
      <item value="migration Version" />
      <item value="deprecated" />
      <item value="caret" />
      <item value="Inspection" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="734" />
        <entry key="ENGLISH" value="735" />
        <entry key="ESTONIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="2" />
        <entry key="PORTUGUESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1609248986133" />
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>