<application>
  <component name="AppStorage">
    <histories>
      <item value="Pocket" />
      <item value="pocket" />
      <item value="Sku" />
      <item value="Drug" />
      <item value="apply Debouching Click Listener" />
      <item value="debouching Click" />
      <item value="init Immersion Bar" />
      <item value="Parcelize" />
      <item value="Coroutine" />
      <item value="duplicate key value violates unique constraint &quot;pk_account&quot;" />
      <item value="Called when the current route has been popped off." />
      <item value="Called when the current route has been pushed." />
      <item value="did Push" />
      <item value="app State" />
      <item value="Mix-in [DiagnosticableTreeMixin] to have access to [debugFillProperties] for the devtool" />
      <item value="Displays an Android View that continues showing the launch screen Drawable until Flutter paints its first frame, then this splash screen fades out. A splash screen is useful to avoid any visual gap between the end of Android's launch screen and the painting of Flutter's first frame." />
      <item value="Specifies an Android theme to apply to this Activity as soon as the Android process has started. This theme is visible to the user while the Flutter UI initializes. After that, this theme continues to determine the Window background behind the Flutter UI." />
      <item value="advised" />
      <item value="precompiled" />
      <item value="Could not build the precompiled application for the device." />
      <item value="enabled" />
      <item value="experimental" />
      <item value="Repository" />
      <item value="Sliver" />
      <item value="Sliver Fill Remaining" />
      <item value="Slivers" />
      <item value="System Chrome" />
      <item value="Controls specific aspects of the operating system's graphical interface and how it interacts with the application." />
      <item value="Specifies the set of system overlays to have visible when the application is running." />
      <item value="footer" />
      <item value="Resource belongs to video capture device, like camera." />
      <item value="Resource belongs to protected media identifier. After the user grants this resource, the origin can use EME APIs to generate the license requests." />
      <item value="'This is the term used in the 2014 version of material design. The modern term is subtitle1. ' 'This feature was deprecated after v1.13.8.'" />
      <item value="Performs an operation repeatedly until it returns `false`. The operation, [action], may be either synchronous or asynchronous. The operation is called repeatedly as long as it returns either the [bool] value `true` or a `Future&lt;bool&gt;` which completes with the value `true`. If a call to [action] returns `false` or a [Future] that completes to `false`, iteration ends and the future returned by [doWhile] is completed with a `null` value. If a call to [action] throws or a future returned by [action] completes with an error, iteration ends and the future returned by [doWhile] completes with the same error. Calls to [action] may happen at any time, including immediately after calling `doWhile`. The only restriction is a new call to [action] won't happen before the previous call has returned, and if it returned a `Future&lt;bool&gt;`, not until that future has completed." />
      <item value="Waits for multiple futures to complete and collects their results. Returns a future which will complete once all the provided futures have completed, either with their results, or with an error if any of the provided futures fail. The value of the returned future will be a list of all the values that were produced in the order that the futures are provided by iterating [futures]. If any future completes with an error, then the returned future completes with that error. If further futures also complete with errors, those errors are discarded. If `eagerError` is true, the returned future completes with an error immediately on the first error from one of the futures. Otherwise all futures must complete before the returned future is completed (still with the first error; the remaining errors are silently dropped). In the case of an error, [cleanUp] (if provided), is invoked on any non-null result of successful futures. This makes it possible to `cleanUp` resources that would otherwise be lost (since the returned future does not provide access to these values). The [cleanUp] function is unused if there is no error. The call to [cleanUp] should not throw. If it does, the error will be an uncaught asynchronous error." />
      <item value="Returns the result of the first future in [futures] to complete. The returned future is completed with the result of the first future in [futures] to report that it is complete, whether it's with a value or an error. The results of all the other futures are discarded. If [futures] is empty, or if none of its futures complete, the returned future never completes." />
      <item value="Refresh" />
      <item value="Show the refresh indicator and run the refresh callback as if it had been started interactively. If this method is called while the refresh callback is running, it quietly does nothing. Creating the [RefreshIndicator] with a [GlobalKey&lt;RefreshIndicatorState&gt;] makes it possible to refer to the [RefreshIndicatorState]. The future returned from this method completes when the [RefreshIndicator.onRefresh] callback's future completes. If you await the future returned by this function from a [State], you should check that the state is still [mounted] before calling [setState]. When initiated in this manner, the refresh indicator is independent of any actual scroll view. It defaults to showing the indicator at the top. To show it at the bottom, set `atTop` to false." />
      <item value="The domain of where to find the error code. This field is only available on iOS and represents a &quot;domain&quot; from where the [errorCode] is from. This value is taken directly from an `NSError` in Objective-C. See https:developer.apple.comlibraryarchivedocumentationCocoaConceptualErrorHandlingCocoaErrorObjectsDomainsErrorObjectsDomains.html for more information on error handling on iOS." />
      <item value="Description of the error that can be used to communicate the problem to the user." />
      <item value="Gets the URL for which the resource request was made. This value is not provided on iOS. Alternatively, you can keep track of the last values provided to [WebViewPlatformController.loadUrl]." />
      <item value="Invoked when a web resource has failed to load. This can be called for any resource (iframe, image, etc.), not just for the main page." />
      <item value="Invoked when a page has finished loading. This is invoked only for the main frame. When [onPageFinished] is invoked on Android, the page being rendered may not be updated yet. When invoked on iOS or Android, any Javascript code that is embedded directly in the HTML has been loaded and code injected with [WebViewController.evaluateJavascript] can assume this." />
      <item value="Consults the current route's [Route.willPop] method, and acts accordingly, potentially popping the route as a result; returns whether the pop request should be considered handled. {@template flutter.widgets.navigator.maybePop} If [Route.willPop] returns [RoutePopDisposition.pop], then the [pop] method is called, and this method returns true, indicating that it handled the pop request. If [Route.willPop] returns [RoutePopDisposition.doNotPop], then this method returns true, but does not do anything beyond that. If [Route.willPop] returns [RoutePopDisposition.bubble], then this method returns false, and the caller is responsible for sending the request to the containing scope (e.g. by closing the application). This method is typically called for a user-initiated [pop]. For example on Android it's called by the binding for the system's back button. The `T` type argument is the type of the return value of the current route. (Typically this isn't known; consider specifying `dynamic` or `Null`.) {@endtemplate} See also: [Form], which provides an `onWillPop` callback that enables the form to veto a [pop] initiated by the app's back button. [ModalRoute], which provides a `scopedWillPopCallback` that can be used to define the route's `willPop` method." />
      <item value="unrestricted" />
      <item value="is Scroll Controlled" />
      <item value="shrink Wrap" />
      <item value="separated" />
      <item value="Paged" />
      <item value="Fetch" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="766" />
        <entry key="ENGLISH" value="767" />
        <entry key="ESTONIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="4" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="2" />
        <entry key="PORTUGUESE" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1611048071991" />
  </component>
</application>